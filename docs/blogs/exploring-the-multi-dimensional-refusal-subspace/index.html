<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Thomas Winninger">
<meta name="dcterms.date" content="2025-10-15">

<title>Research note: Exploring the multi-dimensional refusal subspace in reasoning models – Thomas Winninger</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../assets/favicon.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-919c7ec90743d9b1e9761dff04b41dfc.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-0e6b5171f1292a58de0ff8a7af83c33b.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-919c7ec90743d9b1e9761dff04b41dfc.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-0c777506123ec0af8568e49e273bc51f.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-329f76175cbb6fc5ab394fed898235b2.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<link href="../../site_libs/bootstrap/bootstrap-0c777506123ec0af8568e49e273bc51f.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": true,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles/styles.css">
<meta property="og:title" content="Research note: Exploring the multi-dimensional refusal subspace in reasoning models – Thomas Winninger">
<meta property="og:description" content="My (Thomas Winninger) personal website.">
<meta property="og:image" content="https://sckathach.github.io/blogs/exploring-the-multi-dimensional-refusal-subspace/assets/cosine_pr_llama3.2_1b.svg">
<meta property="og:site_name" content="Thomas Winninger">
<meta name="twitter:title" content="Research note: Exploring the multi-dimensional refusal subspace in reasoning models – Thomas Winninger">
<meta name="twitter:description" content="">
<meta name="twitter:image" content="https://sckathach.github.io/blogs/exploring-the-multi-dimensional-refusal-subspace/assets/cosine_pr_llama3.2_1b.svg">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-fixed quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Thomas Winninger</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../blogs/subspace-rerouting/index.html"> 
<span class="menu-text">SSR</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../research.html"> 
<span class="menu-text">Research</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Writing</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools tools-wide">
    <a href="https://github.com/sckathach" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-github"></i></a>
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Toggle reader mode">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#evidence-for-multi-dimensionality" id="toc-evidence-for-multi-dimensionality" class="nav-link active" data-scroll-target="#evidence-for-multi-dimensionality">Evidence for multi-dimensionality</a>
  <ul class="collapse">
  <li><a href="#a-single-direction-computed-via-different-methods-gives-different-results" id="toc-a-single-direction-computed-via-different-methods-gives-different-results" class="nav-link" data-scroll-target="#a-single-direction-computed-via-different-methods-gives-different-results">A single direction computed via different methods gives different results</a></li>
  <li><a href="#ablating-a-single-direction-is-no-longer-enough-to-remove-refusal" id="toc-ablating-a-single-direction-is-no-longer-enough-to-remove-refusal" class="nav-link" data-scroll-target="#ablating-a-single-direction-is-no-longer-enough-to-remove-refusal">Ablating a single direction is no longer enough to remove refusal</a></li>
  <li><a href="#computing-the-refusal-direction-through-optimization-yields-better-results-than-the-difference-in-means" id="toc-computing-the-refusal-direction-through-optimization-yields-better-results-than-the-difference-in-means" class="nav-link" data-scroll-target="#computing-the-refusal-direction-through-optimization-yields-better-results-than-the-difference-in-means">Computing the refusal direction through optimization yields better results than the difference in means</a></li>
  </ul></li>
  <li><a href="#characterizing-the-refusal-cone-with-a-practical-clustering-based-approach" id="toc-characterizing-the-refusal-cone-with-a-practical-clustering-based-approach" class="nav-link" data-scroll-target="#characterizing-the-refusal-cone-with-a-practical-clustering-based-approach">Characterizing the refusal cone with a practical clustering-based approach</a>
  <ul class="collapse">
  <li><a href="#creation-of-the-variety-dataset" id="toc-creation-of-the-variety-dataset" class="nav-link" data-scroll-target="#creation-of-the-variety-dataset">Creation of the variety dataset</a></li>
  <li><a href="#selecting-a-limited-number-of-directions" id="toc-selecting-a-limited-number-of-directions" class="nav-link" data-scroll-target="#selecting-a-limited-number-of-directions">Selecting a limited number of directions</a></li>
  <li><a href="#testing-the-directions" id="toc-testing-the-directions" class="nav-link" data-scroll-target="#testing-the-directions">Testing the directions</a></li>
  </ul></li>
  <li><a href="#results" id="toc-results" class="nav-link" data-scroll-target="#results">Results</a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/Sckathach/Sckathach.github.io/edit/main/blogs/exploring-the-multi-dimensional-refusal-subspace/index.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/Sckathach/Sckathach.github.io/blob/main/blogs/exploring-the-multi-dimensional-refusal-subspace/index.qmd" class="toc-action"><i class="bi empty"></i>View source</a></li><li><a href="https://github.com/Sckathach/Sckathach.github.io/issues" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Research note: Exploring the multi-dimensional refusal subspace in reasoning models</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Thomas Winninger </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">October 15, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<blockquote class="blockquote">
<p><em>This work was conducted during my internship at NICT under the supervision of Chansu Han.</em></p>
</blockquote>
<p>Over the past year, I’ve been studying interpretability and analyzing what happens inside large language models (LLMs) during adversarial attacks. One of my favorite findings is the discovery of a <strong>refusal subspace</strong> in the model’s feature space, which can, in small models, be reduced to a single dimension (<span class="citation" data-cites="arditi_refusal_2024">Arditi et al. (<a href="#ref-arditi_refusal_2024" role="doc-biblioref">2024</a>)</span>). This subspace explains why some jailbreaks work, and can also be used to create new ones efficiently.</p>
<p>I previously suggested that this subspace might not be one-dimensional, and <span class="citation" data-cites="wollschläger_geometry_2025">Wollschläger et al. (<a href="#ref-wollschläger_geometry_2025" role="doc-biblioref">2025</a>)</span> confirmed this, introducing a method to characterize it. However, their approach relies on gradient-based optimization and is too computationally heavy for small setups, especially for my laptop, which prevents me from doing the experiments I would like to.</p>
<p>Hence, I propose a cheaper (though less precise) method to study this structure, along with new experimental evidence (especially on reasoning models) showing that we need to consider <strong>multiple dimensions</strong>, rather than a single refusal vector, for larger models.</p>
<section id="evidence-for-multi-dimensionality" class="level2">
<h2 class="anchored" data-anchor-id="evidence-for-multi-dimensionality">Evidence for multi-dimensionality</h2>
<p>Mechanistic interpretability research (<span class="citation" data-cites="nanda_comprehensive_2022">Nanda (<a href="#ref-nanda_comprehensive_2022" role="doc-biblioref">2022</a>)</span>; <span class="citation" data-cites="hasting_introduction_2024">Hastings-Woodhouse (<a href="#ref-hasting_introduction_2024" role="doc-biblioref">2024</a>)</span>) has shown that some model behaviors can be expressed linearly in activation space (<span class="citation" data-cites="park_linear_2024">Park, Choe, and Veitch (<a href="#ref-park_linear_2024" role="doc-biblioref">2024</a>)</span>). For example, by comparing activations between contrastive pairs such as <em>“How to create a bomb?”</em> vs.&nbsp;<em>“How to create a website?”</em>, we can extract a refusal direction, a vector representing the model’s tendency to reject harmful queries (<span class="citation" data-cites="arditi_refusal_2024">Arditi et al. (<a href="#ref-arditi_refusal_2024" role="doc-biblioref">2024</a>)</span>).</p>
<p>While earlier work assumed this direction was one-dimensional, evidence suggests that refusal actually spans a <strong>multi-dimensional subspace</strong>, especially in larger models (<span class="citation" data-cites="wollschläger_geometry_2025">Wollschläger et al. (<a href="#ref-wollschläger_geometry_2025" role="doc-biblioref">2025</a>)</span>; <span class="citation" data-cites="winninger_using_2025">Winninger, Addad, and Kapusta (<a href="#ref-winninger_using_2025" role="doc-biblioref">2025</a>)</span>).</p>
<section id="a-single-direction-computed-via-different-methods-gives-different-results" class="level3">
<h3 class="anchored" data-anchor-id="a-single-direction-computed-via-different-methods-gives-different-results">A single direction computed via different methods gives different results</h3>
<p>When refusal directions are extracted using different techniques, such as the <strong>difference in means (DIM)</strong><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> and <strong>probe classifiers</strong><a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>, they are highly but not perfectly aligned. With cosine similarities descending to <span class="math inline">\(0.3\)</span>, this contradicts the one-dimensional hypothesis.</p>
<div id="fig-cosine" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-cosine-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="assets/cosine_pr_llama3.2_1b.svg" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-cosine-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Cosine similarity between refusal directions extracted via different methods across layers of Llama 3.2 1B. While the similarity is high in early layers, it decreases in later ones, with a minimal value of <span class="math inline">\(0.39\)</span>—still meaningful in <span class="math inline">\(\mathbb{R}^{\text{d\_embed}}\)</span>, but far from the <span class="math inline">\(1\)</span> expected if refusal truly occupied just one dimension.
</figcaption>
</figure>
</div>
<p>This phenomenon can also be observed when training multiple probes with different random seeds: they converge to distinct directions, again showing lower cosine similarity than expected.</p>
</section>
<section id="ablating-a-single-direction-is-no-longer-enough-to-remove-refusal" class="level3">
<h3 class="anchored" data-anchor-id="ablating-a-single-direction-is-no-longer-enough-to-remove-refusal">Ablating a single direction is no longer enough to remove refusal</h3>
<p>Using the ablation method proposed by <span class="citation" data-cites="arditi_refusal_2024">Arditi et al. (<a href="#ref-arditi_refusal_2024" role="doc-biblioref">2024</a>)</span> no longer works for recent models, especially those with more than 4 billion parameters. The attack success rate (ASR) can even drop to <span class="math inline">\(0\%\)</span> on models like Llama 3.2 3B.</p>
</section>
<section id="computing-the-refusal-direction-through-optimization-yields-better-results-than-the-difference-in-means" class="level3">
<h3 class="anchored" data-anchor-id="computing-the-refusal-direction-through-optimization-yields-better-results-than-the-difference-in-means">Computing the refusal direction through optimization yields better results than the difference in means</h3>
<p>During my experiments with SSR (<span class="citation" data-cites="winninger_using_2025">Winninger, Addad, and Kapusta (<a href="#ref-winninger_using_2025" role="doc-biblioref">2025</a>)</span>), I observed that adversarial attacks based on probes consistently outperformed those based on DIM, often by a large margin (50% ASR vs.&nbsp;90% ASR).</p>
<p><span class="citation" data-cites="wollschläger_geometry_2025">Wollschläger et al. (<a href="#ref-wollschläger_geometry_2025" role="doc-biblioref">2025</a>)</span> reported similar findings and extended the optimization to multiple directions, forming what they called the <strong>refusal cone</strong>. This concept helps explain the observations: while DIM provides one direction within the refusal cone, probe-based methods converge toward a different, more efficient direction, essentially sampling distinct regions of the same cone.</p>
</section>
</section>
<section id="characterizing-the-refusal-cone-with-a-practical-clustering-based-approach" class="level2">
<h2 class="anchored" data-anchor-id="characterizing-the-refusal-cone-with-a-practical-clustering-based-approach">Characterizing the refusal cone with a practical clustering-based approach</h2>
<p>The idea behind the cheaper refusal cone extraction method is straightforward: if large models encode different categories of harmful content differently, then computing refusal directions per topic should expose several distinct vectors.</p>
<section id="creation-of-the-variety-dataset" class="level3">
<h3 class="anchored" data-anchor-id="creation-of-the-variety-dataset">Creation of the variety dataset</h3>
<p>I merged multiple harmful datasets, including AdvBench (<span class="citation" data-cites="zou_universal_2023">Zou et al. (<a href="#ref-zou_universal_2023" role="doc-biblioref">2023</a>)</span>) and StrongREJECT (<span class="citation" data-cites="souly_strongreject_2024">Souly et al. (<a href="#ref-souly_strongreject_2024" role="doc-biblioref">2024</a>)</span>), into a unified BigBench-style dataset of about 1,200 samples. Using a sentence transformer embedding and HDBSCAN clustering, I grouped semantically similar prompts together and used an LLM to label each cluster, resulting in 74 distinct categories<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>.</p>
<p>By computing difference-in-means vectors for each cluster, I obtained multiple non-collinear refusal directions with cosine similarities around 0.3, confirming that they occupy different regions of the subspace. These refusal directions also have interpretable semantic meaning, being linked to the topics of their clusters.</p>
<p>Of course, this method doesn’t guarantee full coverage of the refusal cone.</p>
</section>
<section id="selecting-a-limited-number-of-directions" class="level3">
<h3 class="anchored" data-anchor-id="selecting-a-limited-number-of-directions">Selecting a limited number of directions</h3>
<p>This method yields multiple directions (12 in my setup). To extract only a few representative ones, several options can be used:</p>
<ul>
<li>Use singular value decomposition to extract a basis<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>.<br>
</li>
<li>Select the “least aligned” directions by minimizing cosine similarity between pairs<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>.<br>
</li>
<li>Select a random subset.</li>
</ul>
<p><span class="citation" data-cites="wollschläger_geometry_2025">Wollschläger et al. (<a href="#ref-wollschläger_geometry_2025" role="doc-biblioref">2025</a>)</span> constructed a basis with the Gram-Schmidt algorithm, but I found it less efficient than the second method, which simply selects the best candidates. Thus, I’ll be using the second method for the rest of this work.</p>
<blockquote class="blockquote">
<p>Even though, in practice, the subspace found by the cone method may be smaller than that found by SVD, this is not guaranteed<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>.</p>
</blockquote>
</section>
<section id="testing-the-directions" class="level3">
<h3 class="anchored" data-anchor-id="testing-the-directions">Testing the directions</h3>
<p>Once the directions are found, we can steer the model to induce or reduce refusal. Alternatively, we can directly edit the model by ablating the directions from its weights, producing an edited version with the refusal cone removed. I followed <span class="citation" data-cites="arditi_refusal_2024">Arditi et al. (<a href="#ref-arditi_refusal_2024" role="doc-biblioref">2024</a>)</span>’s approach, ablating every matrix writing to the residual stream<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>.</p>
<p>These edited models can then be tested with two main metrics:</p>
<ol type="1">
<li><strong>Refusal susceptibility:</strong> Is the edited model more likely to answer harmful prompts?<br>
</li>
<li><strong>Task performance:</strong> Does the edited model retain performance on harmless tasks?</li>
</ol>
<p>For (1), I used an LLM-as-a-judge setup with two evaluators—one stricter than the other—to produce a range rather than a single value.<br>
For (2), I evaluated using AI Inspect on the MMLU benchmark<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>.</p>
</section>
</section>
<section id="results" class="level2">
<h2 class="anchored" data-anchor-id="results">Results</h2>
<div id="fig-multi" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-multi-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="assets/asr_qwen_rs.svg" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-multi-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: Attack Success Rate (ASR) on the vanilla harmful dataset (no jailbreak) using Qwen3 models with different numbers of ablated refusal directions. 0 corresponds to the original model. <strong>Dark bars:</strong> Gemini evaluation. <strong>Light bars:</strong> Mistral Nemo evaluation, which gives slightly higher scores.
</figcaption>
</figure>
</div>
<p><a href="#fig-multi" class="quarto-xref">Figure&nbsp;2</a> shows that as more refusal directions are ablated, the distribution shifts rightward toward higher compliance scores—even without jailbreaks or adversarial suffixes. More importantly, while ablating a single direction is insufficient for larger models (e.g., Qwen3 8B and 14B), multiple directions succeed in reducing refusal.</p>
<div id="fig-mmlu" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-mmlu-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="assets/mmlu_qwen_rs.svg" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-mmlu-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3: Scores on the MMLU benchmark to assess retention on harmless tasks.
</figcaption>
</figure>
</div>
<p>As shown in <a href="#fig-mmlu" class="quarto-xref">Figure&nbsp;3</a>, this method does not significantly degrade model performance on harmless tasks, at least on MMLU. The only exception is Qwen3 14B, likely due to floating-point precision issues (float16 editing vs.&nbsp;float32 for others).</p>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>The multi-dimensionality of the refusal subspace is not a new discovery, but this work shows that it also applies to newer and reasoning models. Moreover, it provides a simple, low-cost method that can run on local hardware and help advance interpretability and alignement research.</p>



</section>


<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-arditi_refusal_2024" class="csl-entry" role="listitem">
Arditi, Andy, Oscar Obeso, Aaquib Syed, Daniel Paleka, Nina Panickssery, Wes Gurnee, and Neel Nanda. 2024. <span>“Refusal in Language Models Is Mediated by a Single Direction.”</span> <a href="https://arxiv.org/abs/2406.11717">https://arxiv.org/abs/2406.11717</a>.
</div>
<div id="ref-chu_jailbreak_2025" class="csl-entry" role="listitem">
Chu, Junjie, Yugeng Liu, Ziqing Yang, Xinyue Shen, Michael Backes, and Yang Zhang. 2025. <span>“JailbreakRadar: Comprehensive Assessment of Jailbreak Attacks Against LLMs.”</span> <a href="https://arxiv.org/abs/2402.05668">https://arxiv.org/abs/2402.05668</a>.
</div>
<div id="ref-hasting_introduction_2024" class="csl-entry" role="listitem">
Hastings-Woodhouse, Sarah. 2024. <span>“Introduction to Mechanistic Interpretability.”</span>
</div>
<div id="ref-he_jailbreaklens_2024" class="csl-entry" role="listitem">
He, Zeqing, Zhibo Wang, Zhixuan Chu, Huiyu Xu, Rui Zheng, Kui Ren, and Chun Chen. 2024. <span>“JailbreakLens: Interpreting Jailbreak Mechanism in the Lens of Representation and Circuit.”</span> <a href="https://arxiv.org/abs/2411.11114">https://arxiv.org/abs/2411.11114</a>.
</div>
<div id="ref-mazeika_harmbench_2024" class="csl-entry" role="listitem">
Mazeika, Mantas, Long Phan, Xuwang Yin, Andy Zou, Zifan Wang, Norman Mu, Elham Sakhaee, et al. 2024. <span>“HarmBench: A Standardized Evaluation Framework for Automated Red Teaming and Robust Refusal.”</span> <a href="https://arxiv.org/abs/2402.04249">https://arxiv.org/abs/2402.04249</a>.
</div>
<div id="ref-nanda_comprehensive_2022" class="csl-entry" role="listitem">
Nanda, Neel. 2022. <span>“A Comprehensive Mechanistic Interpretability Explainer &amp; Glossary,”</span> December.
</div>
<div id="ref-park_linear_2024" class="csl-entry" role="listitem">
Park, Kiho, Yo Joong Choe, and Victor Veitch. 2024. <span>“The Linear Representation Hypothesis and the Geometry of Large Language Models.”</span> <a href="https://arxiv.org/abs/2311.03658">https://arxiv.org/abs/2311.03658</a>.
</div>
<div id="ref-qiu_latent_2023" class="csl-entry" role="listitem">
Qiu, Huachuan, Shuai Zhang, Anqi Li, Hongliang He, and Zhenzhong Lan. 2023. <span>“Latent Jailbreak: A Benchmark for Evaluating Text Safety and Output Robustness of Large Language Models.”</span> <a href="https://arxiv.org/abs/2307.08487">https://arxiv.org/abs/2307.08487</a>.
</div>
<div id="ref-souly_strongreject_2024" class="csl-entry" role="listitem">
Souly, Alexandra, Qingyuan Lu, Dillon Bowen, Tu Trinh, Elvis Hsieh, Sana Pandey, Pieter Abbeel, et al. 2024. <span>“A StrongREJECT for Empty Jailbreaks.”</span> <a href="https://arxiv.org/abs/2402.10260">https://arxiv.org/abs/2402.10260</a>.
</div>
<div id="ref-winninger_using_2025" class="csl-entry" role="listitem">
Winninger, Thomas, Boussad Addad, and Katarzyna Kapusta. 2025. <span>“Using Mechanistic Interpretability to Craft Adversarial Attacks Against Large Language Models.”</span> <a href="https://arxiv.org/abs/2503.06269">https://arxiv.org/abs/2503.06269</a>.
</div>
<div id="ref-wollschläger_geometry_2025" class="csl-entry" role="listitem">
Wollschläger, Tom, Jannes Elstner, Simon Geisler, Vincent Cohen-Addad, Stephan Günnemann, and Johannes Gasteiger. 2025. <span>“The Geometry of Refusal in Large Language Models: Concept Cones and Representational Independence.”</span> <a href="https://arxiv.org/abs/2502.17420">https://arxiv.org/abs/2502.17420</a>.
</div>
<div id="ref-zou_universal_2023" class="csl-entry" role="listitem">
Zou, Andy, Zifan Wang, Nicholas Carlini, Milad Nasr, J. Zico Kolter, and Matt Fredrikson. 2023. <span>“Universal and Transferable Adversarial Attacks on Aligned Language Models.”</span> <a href="https://arxiv.org/abs/2307.15043">https://arxiv.org/abs/2307.15043</a>.
</div>
</div></section><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p><strong>Extracting the refusal direction with the Difference-in-Means (DIM) method</strong></p>
<p>This is the method from <span class="citation" data-cites="arditi_refusal_2024">Arditi et al. (<a href="#ref-arditi_refusal_2024" role="doc-biblioref">2024</a>)</span>.<br>
Given pairs of harmful and harmless prompts (e.g., “How to create a bomb?” vs.&nbsp;“How to create a website?”), we first perform a forward pass to compute the activations of the residual stream at each layer on the last token, after the MLP (<code>resid_post</code>).</p>
<p>At layer <span class="math inline">\(l\)</span>, we obtain <span class="math inline">\(a_l^{\text{hf}}\)</span> for harmful prompts and <span class="math inline">\(a_l^{\text{hl}}\)</span> for harmless ones.<br>
The refusal direction is then computed as:</p>
<p><span class="math display">\[
\vec{r}_l = \frac{1}{|\text{HF}|}\sum_{\text{hf} \in \text{HF}} a_l^{\text{hf}} -
\frac{1}{|\text{HL}|}\sum_{\text{hl} \in \text{HL}} a_l^{\text{hl}}
\]</span></p>
<p>where<br>
- <span class="math inline">\(\vec{r}_l\)</span> is the refusal direction at layer <span class="math inline">\(l\)</span>,<br>
- <span class="math inline">\(\text{HF}\)</span> is the set of harmful prompts, and<br>
- <span class="math inline">\(\text{HL}\)</span> is the set of harmless prompts.</p>
<p>Variants exist: some average activations across all tokens (<span class="citation" data-cites="he_jailbreaklens_2024">He et al. (<a href="#ref-he_jailbreaklens_2024" role="doc-biblioref">2024</a>)</span>), and some use intermediate positions within the transformer layer instead of post-MLP activations.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p><strong>Extracting the refusal direction with probe classifiers</strong></p>
<p>This approach follows <span class="citation" data-cites="he_jailbreaklens_2024">He et al. (<a href="#ref-he_jailbreaklens_2024" role="doc-biblioref">2024</a>)</span> and <span class="citation" data-cites="winninger_using_2025">Winninger, Addad, and Kapusta (<a href="#ref-winninger_using_2025" role="doc-biblioref">2025</a>)</span>.<br>
Activations are collected as in the DIM method, but a one-layer neural probe is trained to predict refusal:</p>
<p><span class="math display">\[
p_l(\text{sentence}) = \sigma(\vec{w}_l^T a_l + b_l)
\]</span></p>
<p>The probe minimizes the binary cross-entropy loss:</p>
<p><span class="math display">\[
\min_{\vec{w}_l, b_l} \sum_{\text{hf} \in \text{HF}} \mathcal{L}(0, \sigma(\vec{w}_l^T a_l^{\text{hf}} + b_l)) +
\sum_{\text{hl} \in \text{HL}} \mathcal{L}(1, \sigma(\vec{w}_l^T a_l^{\text{hl}} + b_l))
\]</span></p>
<p>The normalized weight vector gives the refusal direction: <span class="math inline">\(\vec{r}_l = \vec{w}_l / ||\vec{w}_l||\)</span>.<br>
In practice, the bias term is often close to zero.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p><strong>Creation of the harmful dataset</strong></p>
<p>The combined dataset included AdvBench (<span class="citation" data-cites="zou_universal_2023">Zou et al. (<a href="#ref-zou_universal_2023" role="doc-biblioref">2023</a>)</span>), HarmBench (<span class="citation" data-cites="mazeika_harmbench_2024">Mazeika et al. (<a href="#ref-mazeika_harmbench_2024" role="doc-biblioref">2024</a>)</span>), StrongREJECT (<span class="citation" data-cites="souly_strongreject_2024">Souly et al. (<a href="#ref-souly_strongreject_2024" role="doc-biblioref">2024</a>)</span>), ForbiddenQuestions (<span class="citation" data-cites="chu_jailbreak_2025">Chu et al. (<a href="#ref-chu_jailbreak_2025" role="doc-biblioref">2025</a>)</span>), and MaliciousInstruct (<span class="citation" data-cites="qiu_latent_2023">Qiu et al. (<a href="#ref-qiu_latent_2023" role="doc-biblioref">2023</a>)</span>), totaling 1,271 samples.</p>
<p>Embeddings were computed with <code>text-embedding-embeddinggemma-300m-qat</code>.<br>
HDBSCAN was chosen to handle the uneven, high-dimensional (768D) space.</p>
<p>Clusters were automatically labeled with Qwen3-8B and used to generate contrastive harmless prompts, following the SSR approach (<span class="citation" data-cites="winninger_using_2025">Winninger, Addad, and Kapusta (<a href="#ref-winninger_using_2025" role="doc-biblioref">2025</a>)</span>).</p>
<div id="lst-bbexample" class="json listing quarto-float quarto-figure quarto-figure-left anchored">
<figure class="quarto-float quarto-float-lst figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-lst" id="lst-bbexample-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Listing&nbsp;1: Example of a harmful–harmless pair with topic label in BigBench
</figcaption>
<div aria-describedby="lst-bbexample-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb1"><pre class="sourceCode json code-with-copy"><code class="sourceCode json"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">"harmful_prompt"</span><span class="fu">:</span> <span class="st">"How to create a bomb?"</span><span class="fu">,</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">"harmless_prompt"</span><span class="fu">:</span> <span class="st">"How to create a website?"</span><span class="fu">,</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">"topic"</span><span class="fu">:</span> <span class="st">"explosive creation"</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="fu">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</figure>
</div>
<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></li>
<li id="fn4"><p><strong>Reducing the number of refusal directions with singular value decomposition (SVD)</strong></p>
<p>Given <span class="math inline">\(b\)</span> refusal directions <span class="math inline">\(\vec{r}_l^1, \vec{r}_l^2, \ldots, \vec{r}_l^b\)</span>, concatenate them into a matrix <span class="math inline">\(A\)</span>:</p>
<p><span class="math display">\[
A = [\vec{r}_l^1, \vec{r}_l^2, \ldots, \vec{r}_l^b] \in \mathbb{R}^{b \times \text{d\_embed}}
\]</span></p>
<p>Applying SVD gives:</p>
<p><span class="math display">\[
A = U\Sigma V^T
\]</span></p>
<p>The top-<span class="math inline">\(k\)</span> singular vectors form an orthonormal basis:</p>
<p><span class="math display">\[
\vec{r}_{l}^{\text{SVD}} = [U_{:,1}, U_{:,2}, \ldots, U_{:,k}]
\]</span></p>
<p>This captures the directions that explain the greatest variance.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p><strong>Reducing the number of refusal directions with cosine-similarity selection (MINCOS)</strong></p>
<p>Given <span class="math inline">\(b\)</span> refusal directions <span class="math inline">\(\vec{r}_l^1, \ldots, \vec{r}_l^b\)</span>, compute the Gram matrix of pairwise cosine similarities:</p>
<p><span class="math display">\[
G_{ij} = \frac{\langle \vec{r}_l^i, \vec{r}_l^j \rangle}{||\vec{r}_l^i|| \cdot ||\vec{r}_l^j||}
\]</span></p>
<p>For each direction <span class="math inline">\(i\)</span>, sum its total similarity:</p>
<p><span class="math display">\[
s_i = \sum_{j=1, j \neq i}^{b} |G_{ij}|
\]</span></p>
<p>Select the <span class="math inline">\(k\)</span> directions with the smallest <span class="math inline">\(s_i\)</span>:</p>
<p><span class="math display">\[
\mathcal{I}^{\text{MINCOS}} = \underset{|\mathcal{I}|=k}{\arg\min} \sum_{i \in \mathcal{I}} s_i
\]</span></p>
<p>The selected directions are <span class="math inline">\(\vec{r}_l^{\text{MINCOS}} = \{\vec{r}_l^i : i \in \mathcal{I}^{\text{MINCOS}}\}\)</span>.<br>
Unlike SVD, MINCOS preserves actual learned directions and does not produce orthogonal ones.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p><strong>Relationship between MINCOS and SVD subspaces</strong></p>
<p>The subspace found by MINCOS is not necessarily contained within the one found by SVD.<br>
While SVD captures the top-<span class="math inline">\(k\)</span> principal components (usually explaining 90–95% of the variance), MINCOS may select directions outside this space:</p>
<p><span class="math display">\[
\text{Vect}(\vec{r}_l^{\text{MINCOS}}) \not\subseteq \text{Vect}(\vec{r}_l^{\text{SVD}})
\]</span></p>
<p>In practice, when cosine similarities are moderate (e.g., 0.15), the MINCOS subspace can be considered “smaller” or less destructive than the SVD one.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p><strong>Ablation process: orthogonalizing weight matrices</strong></p>
<p>To remove the influence of a refusal direction <span class="math inline">\(\hat{\vec{r}}\)</span> from the model, we modify each weight matrix that writes to the residual stream.<br>
For an output matrix <span class="math inline">\(W_{\text{out}} \in \mathbb{R}^{d_{\text{embed}} \times d_{\text{input}}}\)</span> (e.g., attention and MLP output matrices), we project it orthogonally:</p>
<p><span class="math display">\[
W_{\text{out}}' \leftarrow W_{\text{out}} - \hat{\vec{r}}\hat{\vec{r}}^T W_{\text{out}}
\]</span></p>
<p>This ensures <span class="math inline">\(W_{\text{out}}'\)</span> no longer writes any component along <span class="math inline">\(\hat{\vec{r}}\)</span>.<br>
In practice, I did not ablate the embedding matrix or the first three layers, as refusal directions are poorly defined there (low probe accuracy).<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p><strong>Evaluation details</strong></p>
<p>Many papers evaluate model refusal using bag-of-words filters or LLM classifiers like Llama Guard, but I find these evaluation very inaccurate, especially for reasoning models:</p>
<ul>
<li>Lexical methods fail because models may begin with neutral phrasing (“Sure, here is…”) before refusing, or refuse implicitly without using “refusal words.”<br>
</li>
<li>Short generations are insufficient: reasoning models may refuse early but then provide harmful content thousands of tokens later (after 4000 tokens for instance with Qwen 3 8b).<br>
</li>
<li>LLM classifiers (e.g., Llama Guard 3) perform poorly on unseen attacks like SSR (<span class="citation" data-cites="winninger_using_2025">Winninger, Addad, and Kapusta (<a href="#ref-winninger_using_2025" role="doc-biblioref">2025</a>)</span>).</li>
</ul>
<p>I don’t have a perfect solution, but I think generating long answers and using a LLM-as-a-judge setup is acceptable (for lack of better techniques), where a larger or equivalent model judges responses to make sure the evaluator understands the conversation. Two judges were used: - Mistral NeMo, which tends to be lenient.<br>
- Gemini 2.5 Flash, which is stricter.</p>
<p>Evaluations were run with the DSPy framework (described <a href="../../blogs/dspy-tap/">here</a>).<br>
Models were quantized to <code>Q4_K_M</code> using Llama.cpp for efficient inference and long-context evaluation (&gt;4000 tokens).</p>
<p>To assess harmless-task performance, I used AI Inspect with MMLU (0-shot, 100 random samples).<br>
Although 100 samples is only a subset of the full 14k-question MMLU benchmark, this setting balances feasibility with acceptable evaluation time, especially for reasoning models.<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/sckathach\.github\.io");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
      &nbsp;
    <div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/Sckathach/Sckathach.github.io/edit/main/blogs/exploring-the-multi-dimensional-refusal-subspace/index.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/Sckathach/Sckathach.github.io/blob/main/blogs/exploring-the-multi-dimensional-refusal-subspace/index.qmd" class="toc-action"><i class="bi empty"></i>View source</a></li><li><a href="https://github.com/Sckathach/Sckathach.github.io/issues" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
    <a class="nav-link" href="https://sckathach.github.io">
<p>Home</p>
</a>
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="../../about.html">
<p>About</p>
</a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>